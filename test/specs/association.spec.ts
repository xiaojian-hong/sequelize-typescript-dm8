/* tslint:disable:max-classes-per-file */

import {expect, use} from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import * as OriginSequelize from 'sequelize-dm8';
import * as Promise from 'bluebird';
import {createSequelize} from "../utils/sequelize";
import {
  Sequelize, Model, Table, Column, BelongsToMany,
  ForeignKey, HasOne, HasMany, BelongsTo, DataType
} from "../../src";
import {expectAutoGeneratedFunctions} from "../utils/association";
import {assertInstance} from "../utils/common";
import {AllowNull} from "../../src/model/column/column-options/allow-null";
import {PrimaryKey} from '../../src/model/column/primary-key/primary-key';

use(chaiAsPromised);

const Association: any = OriginSequelize['Association'];

/* Some base classes that we can override later */
class ConcreteModel<T extends Model<T>> extends Model<T> {
}

class BookModel extends ConcreteModel<BookModel> {
  title: string;
  pages: PageModel[];
  authors: AuthorModel[];
}

class PageModel extends ConcreteModel<PageModel> {
  content: string;
  bookId: number;
  book: BookModel;
}

class AuthorModel extends ConcreteModel<AuthorModel> {
  name: string;
  books: BookWithAuthorModel[];
}

class BookWithAuthorModel extends BookModel {
  authors: AuthorModel[];
}


describe('association', () => {

  let sequelize: Sequelize;

  const jsForDummiesBook = {
    title: 'JS for dummies'
  };

  const crimeAndPunishmentBook = {
    title: 'Crime and Punishment'
  };

  const elisa = {name: 'elisa'};
  const robin = {name: 'robin'};
  const nelly = {name: 'nelly'};
  const brom = {name: 'brom'};

  before(() => {
    sequelize = createSequelize(false);
  });

  describe('One-to-many', () => {
    function oneToManyTestSuites(Book: typeof BookModel, Page: typeof PageModel): void {

      const sherlockHolmesBook = {
        title: 'Sherlock Holmes',
        pages: [
          {content: 'Watson'},
          {content: 'Moriaty'},
        ]
      };

      const page1 = {
        content: 'written by Oscar Wilde',
        book: {
          title: 'The Picture of Dorian Gray'
        }
      };

      const page2 = {
        content: 'js1'
      };
      const page3 = {
        content: 'js2'
      };
      const page4 = {
        content: 'js3'
      };
      const page5 = {
        content: 'js4'
      };

      before(() => sequelize.addModels([Page, Book]));

      beforeEach(() => {
        return sequelize.sync({force: true});
      });

      it('should create models with specified relations', () => {

        expect(Book)
          .to.have.property('associations')
          .that.has.property('pages')
          .that.is.an.instanceOf(Association['HasMany'])
          .and.has.property('foreignKey', 'bookId')
        ;

        expect(Page)
          .to.have.property('associations')
          .that.has.property('book')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .and.has.property('foreignKey', 'bookId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(Book, {singular: 'page', plural: 'pages'});
        expectAutoGeneratedFunctions(Page, {singular: 'book'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );

        it('should create instances without relation', () =>
          Book
            .create({
              title: 'Sherlock Holmes',
              pages: [
                {content: 'Watson'},
                {content: 'Moriaty'},
              ]
            })
            .then(book => {

              expect(book)
                .to.have.property('id')
                .that.is.not.null;

              expect(book)
                .not.to.have.property('pages');
            })
        );
      });

      describe('findByPk()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findByPk(book.id, {include: [Page]}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findByPk(page.id, {include: [Book]}))
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findOne({include: [Page], where: {id: book.id}}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findOne({include: [Book], where: {id: page.id}}))
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findAll({include: [Page], where: {id: book.id}}))
              .then(books => {

                assertInstance(books[0], sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findAll({include: [Book], where: {id: page.id}}))
              .then(pages => {

                assertInstance(pages[0], page1);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then(book => Book.findByPk(book.id))
            .then(book =>
              book
                .$get('pages')
                .then(pages => {

                  assertInstance(pages, sherlockHolmesBook.pages);
                })
            )
        );

        it('should get related instance of source instance', () =>

          Page.create(page1, {include: [Book]})
            .then(page => Page.findByPk(page.id))
            .then(page =>
              page
                .$get('book')
                .then(book => {

                  assertInstance(book, page1.book);
                })
            )
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3)
            ])
            .then(([book, ...pages]) =>
              book
                .$set('pages', pages)
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
              Page.create(page4),
              Page.create(page5),
            ])
            .then(([book, pageA, pageB, pageC, pageD]) =>
              book
                .$set('pages', [pageA, pageB])
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
                // override previous pages
                .then(() => book.$set('pages', [pageC, pageD]))
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  // and check, if there are overridden
                  assertInstance(_book, Object.assign({pages: [page4, page5]}, jsForDummiesBook));
                })
            )
        );

        it('should set relation between specified instance and source instance', () =>

          Promise
            .all([
              Page.create(page2),
              Book.create(jsForDummiesBook)
            ])
            .then(([page, book]) =>
              page
                .$set('book', book)
                .then(() => Page.findByPk(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page2));
                })
            )
        );

        it('should override previous relation', () =>

          Promise
            .all([
              Page.create(page2),
              Book.create(jsForDummiesBook),
              Book.create(crimeAndPunishmentBook),
            ])
            .then(([page, bookA, bookB]) =>
              page
                .$set('book', bookA)
                .then(() => Page.findByPk(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page2));
                })
                .then(() => page.$set('book', bookB))
                .then(() => Page.findByPk(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: crimeAndPunishmentBook}, page2));
                })
            )
        );
      });

      describe('$add', () => {

        it('should add relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
            ])
            .then(([book, page]) =>
              book
                .$add('page', page)
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
            )
        );

        it('should add relations between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
            ])
            .then(([book, ...pages]) =>
              book
                .$add('pages', pages)
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );

        it('should not override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
            ])
            .then(([book, pageA, pageB]) =>
              book
                .$add('page', pageA)
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
                // now we add another page
                .then(() => book.$add('page', pageB))
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  // ... and check, if both pages exist
                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );
      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has many)', () =>

          Book.create(jsForDummiesBook)
            .then((book) =>
              book
                .$create('page', page2)
                .then(page => {

                  assertInstance(page, page2);
                })
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Page.create(page3)
            .then((page) =>
              page
                .$create('book', jsForDummiesBook)
                .then(() => Page.findByPk(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page3));
                })
            )
        );

      });

      describe('$has', () => {

        it('should return true due to relation between specified instances and source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$has('pages', book.pages))
                .then(result => {

                  expect(result).to.be.true;
                })
            )
        );

        it('should return false due to no relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(sherlockHolmesBook, {include: [Page]}),
              Page.create(page3)
            ])
            .then(([book, page]) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$has('pages', page))
                .then(result => {

                  expect(result).to.be.false;
                })
            )
        );

      });

      describe('$count', () => {

        it('should return number of specified relations', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$count('pages'))
                .then(result => {

                  expect(result).to.equal(sherlockHolmesBook.pages.length);
                })
            )
        );

        it('should return 0, since source instance has no relations', () =>

          Book.create(sherlockHolmesBook)
            .then((book) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$count('pages'))
                .then(result => {

                  expect(result).to.equal(0);
                })
            )
        );


      });

      describe('$remove', () => {

        it('should remove relation between specified instance and source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findByPk(book.id, {include: [Page]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('page', _book.pages[0]);
                })
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title,
                    pages: [sherlockHolmesBook.pages[1]]
                  });
                })
            )
        );

        it('should remove relations between specified instances and source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findByPk(book.id, {include: [Page]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('pages', _book.pages);
                })
                .then(() => Book.findByPk(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title
                  });
                })
            )
        );
      });
    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class Book extends Model<Book> implements BookModel {

        @Column
        title: string;

        authors: any[];

        @HasMany(() => Page)
        pages: Page[];
      }

      @Table
      class Page extends Model<Page> implements PageModel {

        @Column(DataType.TEXT)
        content: string;

        @ForeignKey(() => Book)
        bookId: number;

        @BelongsTo(() => Book)
        book: Book;
      }

      oneToManyTestSuites(Book, Page);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class Book2 extends Model<Book2> implements BookModel {

        @Column
        title: string;

        authors: any[];

        @HasMany(() => Page2, 'bookId')
        pages: Page2[];
      }

      @Table
      class Page2 extends Model<Page2> implements PageModel {

        @Column(DataType.TEXT)
        content: string;

        bookId: number;

        @BelongsTo(() => Book2, 'bookId')
        book: Book2;
      }

      oneToManyTestSuites(Book2, Page2);
    });

    function oneToManyWithOptionsTestSuites(Book: typeof BookModel, Page: typeof PageModel, alternateName: boolean = false): void {
      const foreignKey = alternateName ? 'book_id' : 'bookId';

      before(() => sequelize.addModels([Page, Book]));

      beforeEach(() => {
        return sequelize.sync({force: true});
      });

      it('should create models with specified relations', () => {
        expect(Book)
          .to.have.property('associations')
          .that.has.property('pages')
          .that.is.an.instanceOf(Association['HasMany'])
          .which.includes({foreignKey})
          .and.has.property('foreignKeyAttribute')
          .which.includes({allowNull: false, name: foreignKey})
        ;

        expect(Book)
          .to.have.property('associations')
          .that.has.property('pages')
          .that.has.property('options')
          .with.property('onDelete', 'CASCADE')
        ;

        expect(Page)
          .to.have.property('associations')
          .that.has.property('book')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .which.includes({foreignKey})
          .and.has.property('foreignKeyAttribute')
          .which.includes({allowNull: false, name: foreignKey})
        ;

        expect(Page)
          .to.have.property('associations')
          .that.has.property('book')
          .that.has.property('options')
          .with.property('onDelete', 'CASCADE')
        ;
      });

      describe('create()', () => {
        it('should fail creating instances that require a primary key', () => {
          const page = {
            content: 'written by Oscar Wilde',
            book: {
              title: 'The Picture of Dorian Gray'
            }
          };

          return Page.create(page, {include: [Book]})
            .catch(err =>
              expect(err.message)
                .to.match(new RegExp(`^notNull Violation: (${Page.name}.${foreignKey}|${foreignKey}) cannot be null$`)));
        });

        it('should create instances that require a parent primary key', () => {
          const book = {
            title: 'Sherlock Holmes',
            pages: [
              {content: 'Watson'},
              {content: 'Moriaty'},
            ]
          };

          return Book.create(book, {include: [Page]})
            .then((actual: any) => {
              expect(actual.id).to.be.gt(0);
              expect(actual.title).to.eq(book.title);
              expect(actual.pages).to.have.lengthOf(2);
              expect(actual.pages[0].id).to.be.gt(0);
              expect(actual.pages[0].content).to.eq(book.pages[0].content);
              expect(actual.pages[1].id).to.be.gt(0);
              expect(actual.pages[1].content).to.eq(book.pages[1].content);
            });
        });
      });
    }

    describe('resolve foreign keys automatically with association options', () => {

      @Table
      class Book3 extends Model<Book3> implements BookModel {

        @Column
        title: string;

        authors: any[];

        @HasMany(() => Page3, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'})
        pages: Page3[];
      }

      @Table
      class Page3 extends Model<Page3> implements PageModel {

        @Column(DataType.TEXT)
        content: string;

        @ForeignKey(() => Book3)
        bookId: number;

        @BelongsTo(() => Book3, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'})
        book: Book3;
      }

      oneToManyWithOptionsTestSuites(Book3, Page3);
    });

    describe('set foreign keys explicitly with association options', () => {

      @Table
      class Book4 extends Model<Book4> implements BookModel {

        @Column
        title: string;

        authors: any[];

        @HasMany(() => Page4, {foreignKey: {allowNull: false, name: 'book_id'}, onDelete: 'CASCADE'})
        pages: Page4[];
      }

      @Table
      class Page4 extends Model<Page4> implements PageModel {

        @Column(DataType.TEXT)
        content: string;

        @ForeignKey(() => Book4)
        bookId: number;

        @BelongsTo(() => Book4, {foreignKey: {allowNull: false, name: 'book_id'}, onDelete: 'CASCADE'})
        book: Book4;
      }

      oneToManyWithOptionsTestSuites(Book4, Page4, true);
    });

    describe('set foreign keys explicitly via options', () => {

      @Table
      class Book5 extends Model<Book5> implements BookModel {

        @Column
        title: string;

        authors: any[];

        @HasMany(() => Page5, {foreignKey: 'bookId'})
        pages: Page5[];
      }

      @Table
      class Page5 extends Model<Page5> implements PageModel {

        @Column(DataType.TEXT)
        content: string;

        bookId: number;

        @BelongsTo(() => Book5, {foreignKey: 'bookId'})
        book: Book5;
      }

      oneToManyTestSuites(Book5, Page5);
    });

    it('Should throw error when trying to resolve associations with uninitialized Models', () => {

      const _sequelize = createSequelize(false);

      @Table
      class Friend extends Model<Friend> {
      }

      @Table
      class User extends Model<User> {

        @HasOne(() => Friend, 'userId')
        friend: Friend;
      }

      expect(() =>
        _sequelize.addModels([User])
      ).to.throw(new RegExp('Friend has not been defined'));
    });
  });

  describe('Many-to-many', () => {

    function manyToManyTestSuites(Book: typeof BookModel, Author: typeof AuthorModel, AuthorBook?: typeof ConcreteModel): void {

      const models: Array<typeof ConcreteModel> = [Book, Author];

      if (AuthorBook) {
        models.push(AuthorBook);
      }

      const sherlockHolmesBook = {
        title: 'Sherlock Holmes',
        authors: [
          {name: 'Sir Arthur Conan Doyle'},
          {name: 'No Ghost'},
        ]
      };
      const julesVerne = {
        name: 'Jules Verne',
        books: [
          {title: 'Journey to the Center of the Earth'},
          {title: 'Twenty Thousand Leagues Under the Sea'},
        ]
      };

      before(() => sequelize.addModels(models));

      beforeEach(() => sequelize.sync({force: true}));

      it('should create models with specified relations', () => {

        expect(Book)
          .to.have.property('associations')
          .that.has.property('authors')
          .that.is.an.instanceOf(Association['BelongsToMany'])
          .and.has.property('foreignKey', 'bookId')
        ;

        expect(Author)
          .to.have.property('associations')
          .that.has.property('books')
          .that.is.an.instanceOf(Association['BelongsToMany'])
          .and.has.property('foreignKey', 'authorId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(Book, {singular: 'author', plural: 'authors'});
        expectAutoGeneratedFunctions(Author, {singular: 'book', plural: 'books'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );

        it('should create instances without relation', () =>
          Author.create(julesVerne)
            .then(author => {

              assertInstance(author, {name: julesVerne.name});
            })
        );
      });

      describe('findByPk()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findByPk(book.id, {include: [Author]}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findByPk(author.id, {include: [Book]}))
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findOne({include: [Author], where: {id: book.id}}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findOne({include: [Book], where: {id: author.id}}))
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findAll({include: [Author], where: {id: book.id}}))
              .then(books => {

                assertInstance(books[0], sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findAll({include: [Book], where: {id: author.id}}))
              .then(authors => {

                assertInstance(authors[0], julesVerne);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Promise
            .all([
              Book.create(sherlockHolmesBook, {include: [Author]})
                .then(book => Book.findByPk(book.id))
                .then(book =>
                  book
                    .$get('authors')
                    .then(authors => {

                      assertInstance(authors, sherlockHolmesBook.authors);
                    })
                ),
              Author.create(julesVerne, {include: [Book]})
                .then(author => Author.findByPk(author.id))
                .then(author =>
                  author
                    .$get('books')
                    .then(books => {

                      assertInstance(books, julesVerne.books);
                    })
                )

            ])
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(robin)
            ])
            .then(([book, ...authors]) =>
              book
                .$set('authors', authors)
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, robin]}, jsForDummiesBook));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(nelly),
              Author.create(brom),
              Author.create(robin),
            ])
            .then(([book, _elisa, _nelly, _brom, _robin]) =>
              book
                .$set('authors', [_elisa, _nelly])
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, nelly]}, jsForDummiesBook));
                })
                // override previous authors
                .then(() => book.$set('authors', [_brom, _robin]))
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  // and check, if there are overridden
                  assertInstance(_book, Object.assign({authors: [brom, robin]}, jsForDummiesBook));
                })
            )
        );

      });

      describe('$add', () => {

        it('should add relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
            ])
            .then(([book, _elisa]) =>
              book
                .$add('author', _elisa)
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
            )
        );

        it('should add relations between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(brom),
            ])
            .then(([book, ...authors]) =>
              book
                .$add('authors', authors)
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, brom]}, jsForDummiesBook));
                })
            )
        );

        it('should not override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(brom),
            ])
            .then(([book, _elisa, _brom]) =>
              book
                .$add('author', _elisa)
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
                // now we add another author
                .then(() => book.$add('author', _brom))
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  // ... and check, if both authors exist
                  assertInstance(_book, Object.assign({authors: [elisa, brom]}, jsForDummiesBook));
                })
            )
        );
      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has many)', () =>

          Book.create(jsForDummiesBook)
            .then((book) =>
              book
                .$create('author', elisa)
                .then(author => {

                  assertInstance(author, elisa);
                })
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Author.create(elisa)
            .then((author) =>
              author
                .$create('book', jsForDummiesBook)
                .then(book => {

                  assertInstance(book, jsForDummiesBook);
                })
                .then(() => Author.findByPk(author.id, {include: [Book]}))
                .then(_author => {

                  assertInstance(_author, Object.assign({books: [jsForDummiesBook]}, elisa));
                })
            )
        );

      });

      describe('$has', () => {

        it('should return true due to relation between specified instances and source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$has('authors', book.authors))
                .then(result => {

                  expect(result).to.be.true;
                })
            )
        );

        it('should return false due to no relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(sherlockHolmesBook, {include: [Author]}),
              Author.create(elisa)
            ])
            .then(([book, author]) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$has('authors', author))
                .then(result => {

                  expect(result).to.be.false;
                })
            )
        );

      });

      describe('$count', () => {

        it('should return number of specified relations', () =>

          Book.create(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findByPk(book.id)
                .then(_book => _book.$count('authors'))
                .then(result => {

                  expect(result).to.equal(sherlockHolmesBook.authors.length);
                })
            )
        );

        it('should return 0, since source instance has no relations', () =>

          Author.create(elisa)
            .then((author) =>
              Author
                .findByPk(author.id)
                .then(_author => _author.$count('books'))
                .then(result => {

                  expect(result).to.equal(0);
                })
            )
        );


      });

      describe('$remove', () => {

        it('should remove relation between specified instance and source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findByPk(book.id, {include: [Author]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('author', _book.authors[0]);
                })
                .then(() => Book.findByPk(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title,
                    authors: [sherlockHolmesBook.authors[1]]
                  });
                })
            )
        );

        it('should remove relations between specified instances and source instance', () =>

          Author.create(julesVerne, {include: [Book]})
            .then((author) =>
              Author
                .findByPk(author.id, {include: [Book]})
                .then(_author => {

                  assertInstance(_author, julesVerne);

                  return _author.$remove('books', _author.books);
                })
                .then(() => Author.findByPk(author.id, {include: [Book]}))
                .then(_author => {

                  assertInstance(_author, {
                    name: julesVerne.name
                  });
                })
            )
        );
      });
    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class Book extends BookModel {

        @Column
        title: string;

        @BelongsToMany(() => Author, () => AuthorBook)
        authors: Author[];
      }

      @Table
      class AuthorBook extends Model<AuthorBook> {

        @ForeignKey(() => Book)
        bookId: number;

        @ForeignKey(() => Author)
        authorId: number;

      }

      @Table
      class Author extends Model<Author> {

        @Column
        name: string;

        @BelongsToMany(() => Book, () => AuthorBook)
        books: Book[];
      }

      manyToManyTestSuites(Book, Author, AuthorBook);
    });

    describe('set foreign keys automatically via options', () => {

      @Table
      class Book4 extends BookModel {

        @Column
        title: string;

        @BelongsToMany(() => Author4, {
          through: () => AuthorBook4
        })
        authors: Author4[];
      }

      @Table
      class AuthorBook4 extends Model<AuthorBook4> {

        @ForeignKey(() => Book4)
        bookId: number;

        @ForeignKey(() => Author4)
        authorId: number;
      }

      @Table
      class Author4 extends Model<Author4> {

        @Column
        name: string;

        @BelongsToMany(() => Book4, {
          through: () => AuthorBook4,
        })
        books: Book4[];
      }

      manyToManyTestSuites(Book4, Author4, AuthorBook4);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class Book2 extends BookModel {

        @Column
        title: string;

        @BelongsToMany(() => Author2, 'AuthorBook2', 'bookId', 'authorId')
        authors: Author2[];
      }

      @Table
      class Author2 extends Model<Author2> {

        @Column
        name: string;

        @BelongsToMany(() => Book2, 'AuthorBook2', 'authorId', 'bookId')
        books: Book2[];
      }

      manyToManyTestSuites(Book2, Author2);
    });

    describe('set foreign keys explicitly via options', () => {

      @Table
      class Book3 extends BookModel {

        @Column
        title: string;

        @BelongsToMany(() => Author3, {
          through: 'AuthorBook3',
          foreignKey: 'bookId',
          otherKey: 'authorId',
        })
        authors: Author3[];
      }

      @Table
      class Author3 extends Model<Author3> {

        @Column
        name: string;

        @BelongsToMany(() => Book3, {
          through: 'AuthorBook3',
          foreignKey: 'authorId',
          otherKey: 'bookId',
        })
        books: Book3[];
      }

      manyToManyTestSuites(Book3, Author3);
    });

    describe('set through model via through options', () => {

      @Table
      class Book66 extends Model<Book66> {

        @Column
        title: string;

        pages: any[];

        @BelongsToMany(() => Author66, {
          through: {
            model: () => AuthorBook66,
          }
        })
        authors: Author66[];
      }

      @Table
      class AuthorBook66 extends Model<AuthorBook66> {

        @ForeignKey(() => Book66)
        bookId: number;

        @ForeignKey(() => Author66)
        authorId: number;
      }

      @Table
      class Author66 extends Model<Author66> {

        @Column
        name: string;

        @BelongsToMany(() => Book66, {
          through: {
            model: () => AuthorBook66,
          }
        })
        books: Book66[];
      }

      manyToManyTestSuites(Book66, Author66, AuthorBook66);
    });

    describe('set through model string via through options', () => {

      @Table
      class Book66 extends Model<Book66> {

        @Column
        title: string;

        pages: any[];

        @BelongsToMany(() => Author66, {
          through: {
            model: 'AuthorBook66',
          },
          foreignKey: 'bookId',
          otherKey: 'authorId',
        })
        authors: Author66[];
      }

      @Table
      class Author66 extends Model<Author66> {

        @Column
        name: string;

        @BelongsToMany(() => Book66, {
          through: {
            model: 'AuthorBook66',
          },
          foreignKey: 'authorId',
          otherKey: 'bookId',
        })
        books: Book66[];
      }

      manyToManyTestSuites(Book66, Author66);
    });

    describe('ThroughOptions', () => {

      @Table
      class User77 extends Model<User77> {

        @Column
        name: string;

        @BelongsToMany(() => User77, {
          through: {
            model: () => Subscription,
            scope: {
              targetType: 'user'
            }
          },
          foreignKeyConstraint: true,
          foreignKey: 'subscriberId',
          otherKey: 'targetId',
          constraints: false,
        })
        usersSubscribedTo: User77[];
      }

      @Table
      class Subscription extends Model<Subscription> {

        @PrimaryKey
        @ForeignKey(() => User77)
        @Column
        subscriberId: number;

        @PrimaryKey
        @Column
        targetId: number;

        @Column
        targetType: string;
      }

      before(() => sequelize.addModels([User77, Subscription]));

      it('should set scope in pure sequelize association options', () => {
        expect(User77['associations'].usersSubscribedTo['through'])
          .to.have.property('scope').that.eqls({targetType: 'user'});
      });

    });

    it('Should throw error when trying to resolve associations with uninitialized Models', () => {

      const _sequelize = createSequelize(false);

      @Table
      class UserFriend extends Model<UserFriend> {
      }

      @Table
      class Friend extends Model<Friend> {
      }

      @Table
      class User extends Model<User> {

        @BelongsToMany(() => Friend, () => UserFriend)
        friend: Friend;
      }

      expect(() =>
        _sequelize.addModels([User, Friend])
      ).to.throw(new RegExp('UserFriend has not been defined'));
    });

  });

  describe('One-to-one', () => {

    const userWithAddress = {
      name: 'Sherlock Holmes',
      address: {
        street: 'Bakerstreet',
        city: 'London',
        zipCode: '12345',
        country: 'England',
      }
    };

    const emancipatedAddress = {
      street: 'Bakerstreet',
      city: 'London',
      zipCode: '12345',
      country: 'England',
      user: {
        name: 'hng?'
      }
    };

    const petersAddress = {
      street: '738 Winter Garden DriveForest Hills',
      city: 'New York',
      zipCode: '12345',
      country: 'United States',
    };

    const petersOtherAddress = {
      street: '137 Chrystie Street',
      city: 'New York',
      zipCode: '12345',
      country: 'United States',
    };

    class AbstractUser extends Model<AbstractUser> {
      name: string;
      address: AbstractAddress;
    }

    class AbstractAddress extends Model<AbstractAddress> {
      street: string;
      zipCode: string;
      city: string;
      country: string;
      userId: number;
      user: AbstractUser;
    }

    function oneToOneTestSuites(User: typeof AbstractUser, Address: typeof AbstractAddress): void {

      before(() => sequelize.addModels([User, Address]));

      beforeEach(() => sequelize.sync({force: true}));

      it('should create models with specified relations', () => {

        expect(User)
          .to.have.property('associations')
          .that.has.property('address')
          .that.is.an.instanceOf(Association['HasOne'])
          .and.has.property('foreignKey', 'userId')
        ;

        expect(Address)
          .to.have.property('associations')
          .that.has.property('user')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .and.has.property('foreignKey', 'userId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(User, {singular: 'address'});
        expectAutoGeneratedFunctions(Address, {singular: 'user'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );

        it('should create instances without relation', () =>
          User
            .create(userWithAddress)
            .then(user => {

              expect(user)
                .to.have.property('id')
                .that.is.not.null;

              expect(user)
                .not.to.have.property('address');
            })
        );
      });

      describe('findByPk()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findByPk(user.id, {include: [Address]}))
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findByPk(address.id, {include: [User]}))
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findOne({include: [Address], where: {id: user.id}}))
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findOne({include: [User], where: {id: address.id}}))
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findAll({include: [Address], where: {id: user.id}}))
              .then(users => {

                assertInstance(users[0], userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findAll({include: [User], where: {id: address.id}}))
              .then(addresses => {

                assertInstance(addresses[0], emancipatedAddress);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Promise
            .all([
              User.create(userWithAddress, {include: [Address]})
                .then(user => User.findByPk(user.id))
                .then(user =>
                  user
                    .$get('address')
                    .then(address => {

                      assertInstance(address, userWithAddress.address);
                    })
                ),
              Address.create(emancipatedAddress, {include: [User]})
                .then(author => Address.findByPk(author.id))
                .then(author =>
                  author
                    .$get('user')
                    .then(user => {

                      assertInstance(user, emancipatedAddress.user);
                    })
                )

            ])
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              User.create(elisa),
              Address.create(petersAddress)
            ])
            .then(([user, address]) =>
              user
                .$set('address', address)
                .then(() => User.findByPk(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              User.create(elisa),
              Address.create(petersAddress),
              Address.create(petersOtherAddress),
            ])
            .then(([user, address1, address2]) =>
              user
                .$set('address', address1)
                .then(() => User.findByPk(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
                // override previous authors
                .then(() => user.$set('address', address2))
                .then(() => User.findByPk(user.id, {include: [Address]}))
                .then(_user => {

                  // and check, if there are overridden
                  assertInstance(_user, Object.assign({address: petersOtherAddress}, elisa));
                })
            )
        );

      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has one)', () =>

          User.create(elisa)
            .then((user) =>
              user
                .$create('address', Object.assign({}, petersAddress))
                .then(address => {

                  assertInstance(address, petersAddress);
                })
                .then(() => User.findByPk(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Address.create(petersAddress)
            .then((address) =>
              address
                .$create('user', Object.assign({}, elisa))
                .then(() => Address.findByPk(address.id, {include: [User]}))
                .then(_address => {

                  assertInstance(_address, Object.assign({user: elisa}, petersAddress));
                })
            )
        );

      });

    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class User extends Model<User> {

        @Column
        name: string;

        @HasOne(() => Address)
        address: any; // "any" because of order of execution (in separate classes this will work, I promise)
      }

      @Table
      class Address extends Model<Address> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @ForeignKey(() => User)
        userId: number;

        @BelongsTo(() => User)
        user: User;
      }

      oneToOneTestSuites(User, Address);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class User2 extends Model<User2> {

        @Column
        name: string;

        @HasOne(() => Address2, 'userId')
        address: any; // "any" because of order of execution (in separate classes this will work, I promise)
      }

      @Table
      class Address2 extends Model<Address2> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @BelongsTo(() => User2, 'userId')
        user: User2;

        userId: number;
      }

      oneToOneTestSuites(User2, Address2);
    });

    function oneToOneWithOptionsTestSuites(User: typeof AbstractUser,
                                           Address: typeof AbstractAddress,
                                           alternateName: boolean = false,
                                           onDeleteAction: string = 'CASCADE'): void {
      const foreignKey = alternateName ? 'user_id' : 'userId';

      before(() => sequelize.addModels([User, Address]));

      beforeEach(() => {
        return sequelize.sync({force: true});
      });

      it('should create models with specified relations', () => {
        expect(User)
          .to.have.property('associations')
          .that.has.property('address')
          .that.is.an.instanceOf(Association['HasOne'])
          .which.includes({foreignKey})
          .and.has.property('foreignKeyAttribute')
          .which.includes({allowNull: false, name: foreignKey})
        ;

        expect(User)
          .to.have.property('associations')
          .that.has.property('address')
          .that.has.property('options')
          .with.property('onDelete', onDeleteAction)
        ;

        expect(Address)
          .to.have.property('associations')
          .that.has.property('user')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .which.includes({foreignKey})
          .and.has.property('foreignKeyAttribute')
          .which.includes({allowNull: false, name: foreignKey})
        ;

        expect(Address)
          .to.have.property('associations')
          .that.has.property('user')
          .that.has.property('options')
          .with.property('onDelete', onDeleteAction)
        ;
      });

      describe('create()', () => {
        it('should fail creating instances that require a primary key', () => {

          return Address.create(petersAddress, {include: [User]})
            .catch(err =>
              expect(err.message)
                .to.match(new RegExp(`^notNull Violation: (${Address.name}.${foreignKey}|${foreignKey}) cannot be null$`)));
        });

        it('should create instances that require a parent primary key', () => {
          return User.create(userWithAddress, {include: [Address]})
            .then((actual: any) => {
              assertInstance(actual, userWithAddress);
            });
        });
      });
    }

    describe('resolve foreign keys automatically with association options', () => {

      const ON_DELETE_ACTION = 'SET NULL';

      @Table
      class User3 extends Model<User3> {

        @Column
        name: string;

        @HasOne(() => Address3, {foreignKey: {allowNull: false}, onDelete: ON_DELETE_ACTION})
        address: any;
      }

      @Table
      class Address3 extends Model<Address3> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @AllowNull(false)
        @ForeignKey(() => User3)
        @Column
        userId: number;

        @BelongsTo(() => User3, {foreignKey: {allowNull: false}, onDelete: ON_DELETE_ACTION})
        user: User3;
      }

      oneToOneWithOptionsTestSuites(User3, Address3, false, ON_DELETE_ACTION);
    });

    describe('set foreign keys explicitly with association options', () => {

      @Table
      class User4 extends Model<User4> {

        @Column
        name: string;

        @HasOne(() => Address4, {foreignKey: {allowNull: false, name: 'user_id'}, onDelete: 'CASCADE'})
        address: any;
      }

      @Table
      class Address4 extends Model<Address4> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @BelongsTo(() => User4, {
          foreignKey: {allowNull: false, name: 'user_id'},
          onDelete: 'CASCADE',
        })
        user: User4;

        userId: number;
      }

      oneToOneWithOptionsTestSuites(User4, Address4, true);
    });

    describe('set foreign keys explicitly via options', () => {

      @Table
      class User5 extends Model<User5> {

        @Column
        name: string;

        @HasOne(() => Address5, {foreignKey: 'userId'})
        address: any;
      }

      @Table
      class Address5 extends Model<Address5> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @BelongsTo(() => User5, {foreignKey: 'userId'})
        user: User5;

        userId: number;
      }

      oneToOneTestSuites(User5, Address5);
    });

    describe('set foreign keys explicitly with association options (allowNull: false on foreignKey)', () => {

      @Table
      class User6 extends Model<User6> {

        @Column
        name: string;

        @HasOne(() => Address6, {foreignKey: {allowNull: false}})
        address: any;
      }

      @Table
      class Address6 extends Model<Address6> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @ForeignKey(() => User6)
        @AllowNull(false)
        @Column({field: 'user_id'})
        userId: number;

        @BelongsTo(() => User6, {
          onDelete: 'CASCADE',
          foreignKey: {allowNull: false}
        })
        user: User6;
      }

      oneToOneWithOptionsTestSuites(User6, Address6, false);
    });
  });

});
